---
sidebar_position: 15
---

import Authors from './Authors.tsx';

# 15장 Clean Code 요약 정리

<Authors bookLeader='Xednicoder' />

### 1장 : 깨끗한 코드

> 읽기 쉽게 만들어야 하고
> 유지 보수가 편한, 즉 테스트가 간편한 코드로 작성되어야 하고
> 항상 최적의 코드로 발전시켜야한다.(캠프장은 처음 왔을때보다 더 깨끗하게 해놓고 떠나라)
> 모든 학자마다 차이는 있지만 요약하자면 명료성, 단순성, 표현력 정도가 핵심!!

Q. 깨끗한 코드로 옳지 않은 것은?

1. **시간이 지날 수록 코드가 좋아지는 경우는 없다. 최대한 그 수명을 늘려야한다.**
2. 중복이 많은 코드는 좋지 않다. 최대한 줄이는 것이 좋다

- 설명: 시간이 지날수록 좋아지는 코드를 짜야한다.

### 2장 : 의미 있는 이름

> 의도를 정확히 구분시킨 코드를 통해 그릇된 정보를 피하는게 핵심!!
> 여기서의 의도를 담은 이름은 검색하기도 쉬워야하며 한 단어로 한 개념을 표현할 수 있어야한다.

Q. 의미 있는 이름으로 옳은 것은?

1. 깨끗한 코드는 다른이가 보기에 쉬운 코드다. 한눈에 이해하기 쉬운 유니크한 이름을 짓는 것이 중요하다.
2. **의미가 불분명한 경우 함수, 이름에 맥락을 부여한다. 그래도 안되면 접두어를 붙인다.**

- 설명: 특별한 단어보다 보편적인 단어를 사용하는 것이 좋다.

### 3장 : 함수

> 함수는 작게! 짧게! 만드는게 핵심!!
> 즉, 함수가 단 한가지만 수행할 수 있도록 추상화 수준을 하나로 줄인다.

Q. 함수의 깨끗한 코드로 옳은 것은?

1. **함수에 인수(파라미터)를 쓰는 것은 옳지 않다. 최대한 쓰지 않는 것이 좋다.**
2. **서술적인 이름을 사용한다면 함수의 이름이 길어도 괜찮다.**

### 4장 : 주석

> 주석은 나쁜 코드를 보완하지 못하고, 그 함수를 설명하는 용도로 사용해서는 안되는게 핵심!!
> 온전히 코드로만 그 의도를 표현하는 것이 옳다.

Q. 그렇다면 주석을 왜 쓰는가?

1. **결과를 경고하는 의도 (ex: 필요 없다면 실행하지 마시오)**
2. 이력을 기록하는 의도 (ex: 버그를 수정하였다)

### 5장 : 형식 맞추기

> 원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지가 않는다.
> 누가, 언제라도 코드를 읽기 쉽게 하기 위해서라도 형식을 맞추는 노력은 필요하다.
> 첫 인상이 중요하다(형식에 맞게 짜여진 코드는 즉시 읽기 편하다)

Q. 잘못 된 것은?

1. **코드의 순서는 기능의 실행 순서대로 묶어 정렬 하는 것이 비슷한 개념끼리 묶는 것 보다 유리하다.**
2. 코드의 가로 길이는 80자 이내가 가장 적당하다.

- 설명: 비슷한 개념끼리 묶는 것이 중요하다

### 6장 : 객체와 자료 구조

> 감추고 드러내라 -장규석 왈-
> 자신의 프로젝트가 필요한 유연성이 무엇인지 아는 것이 핵심!
> 새로운 자료 타입을 추가하는 유연성이 필요하면 객체 지향이 유리,
> 새로운 동작을 추가하는 유연성이 필요하면 자료구조와 절차적인 코드가 유리

Q. 디미터 법칙으로 잘못 된 것은?

1. 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙
2. 클래스의 메서드가 반환하는 객체의 매서드만을 호출해야한다.

- 설명: 클래스의 메서드가 반환하는 객체의 메서드는 호출하면 안된다.

### 7장 : 오류 처리

> 뭔가 잘못 될 가능성은 항상 존재한다.
> 잘못된 것을 바로 잡는 책임은 프로그래머에게 있다.
> 오류 처리 하는 코드 때문에 프로그램의 로직을 이해하기 어렵다면 깨끗한 코드라 할 수 없다.
> 즉, 오류처리는 당연히 하게 될텐데 그 코드가 프로그램 코드를 방해해서는 안된다(?)

Q. 다음 중 잘못 된 것은?

1. **null을 전달해야지 null을 반환해서는 안된다.**
2. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해진다. 또한 코드 유지보스도 편해진다.

- 설명: 둘다 하지마

### 8장 : 경계

> 패키지나 라이브러리를 사용하면 다른 외부의 코드가 내부의 코드를 합쳐야하는 상황이 온다.
> 이때 외부와 내가 구현한 코드의 경계를 깔끔하게 처리하는 것이 핵심!!

Q. 다음 중 짐 뉴커크의 '학습테스트'에 대한 설명으로 잘못 된 것은?

1. 우리 코드를 작성해 외부 코드를 호출하기 전 간단한 테스트 케이스를 작성해 외부 코드를 익힌다.
2. **학습테스트로는 외부 코드가 정상적으로 도는지를 확인할 수 없다.**

- 설명: 아니다. 이것을 하기 위한 것이 학습테스트다. 버전이 달라지면 코드를 돌려 확인할 수 있다.

### 9장 : 단위테스트

> 테스트 코드는 실제 코드 만큼 중요하다.
> 테스트 케이스가 없다면 실제 코드를 유연하게 만드는 버팀목도 사라진다.
> 즉, 코드의 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트다.

Q. 다음 중 잘못 된 것은?

1. 실제 코드를 짜기 전에 테스트 코드를 먼저 작성하는 것이 옳다.
2. **실제 코드와 맞먹을 정도의 방대한 테스트 코드를 작성하는 것이 중요하다.**

- 설명: 그럼 심각한 관리 문제를 유발한다.

### 10장 : 클래스

> 코드를 보면 변수목록, 공개함수, 비공개함수 이런식으로 쭉 읽어갈 수 있다.
> 잘 읽어 나가기 위해 캡슐화가 필요해!!
> 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만, 숨겨야한다는 법칙도 없다.
> 캡슐화를 풀어주는 결정은 최후의 수단으로 쓰면 좋다.

Q. 클래스 크기를 줄이는 방법으로 잘못 된 것은?

1. **메서드 이름을 짧고 정확하게 짓는다.**
2. 큰 함수를 작은 함수 여럿으로 나누면 클래스가 많아진다. 그러면서 프로그램의 구조가 투명해진다.

- 설명: 짧지 않아도 된다. 정확하게 짓는다면 길어도 좋다.
